* Core


  Core provides the primitive extensions to the Lua language used by every
other system in the bridge.


Core itself is a lazy loader, with the following interface.

To include =core= without paying for what you don't use, or worrying much
about getting what you need when you need it, do this:

#!lua #noKnit #example
local core = require "core"
#/lua

Any field access will require the requested table.

To make core eager, call it:

#!lua #noKnit #example
local core = require "core" ()
#/lua

This presents the same interface but with every subtable already in memory.

To add the subtables as fields of another table, such as an environment,
pass this as the argument:

#!lua #noKnit #example
require "core" (getfenv(1))
#/lua

The tables, such as =table=, named after global tables in the global table,
are designed as conservative replacements for their namesakes.  Consevative in
that any field present in 'Lua classic' will have an identical value if that
value is a function.

The lazy loader is a closed-over __index and look like this:

#!lua
local function lazy_load_gen(requires)
   return function(tab, key)
      if requires[key] then
         -- put the return on the core table
         tab[key] = require(requires[key])
         return tab[key]
      else
         error("core doesn't have a module " .. tostring(key))
      end
   end
end
#/lua

The callable being efficiently implemented thus:

#!lua
local function call_gen(requires)
   return function(tab, env)
      local _;
      for k in pairs(requires) do
         _ = tab[k]
         if env then
            -- assign the now cached value as a global or at least slot
            env[k] = tab[k]
         end
      end

      return tab
   end
end
#/lua

Which is a bit funny looking, but does mean that any tweaks or enhancements to
the indexer will be seen in the caller without further ado.

Core ends up looking like this:

#!lua
local core_modules = {
   cluster    = "qor:core/cluster",
   coro       = "qor:core/coro",
   fn         = "qor:core/fn",
   math       = "qor:core/math",
   meta       = "qor:core/meta",
   ["module"] = "qor:core/module",
   string     = "qor:core/string",
   table      = "qor:core/table",
   thread     = "qor:core/thread",
   env        = "qor:core/env",
   uv         = "qor:core/uv",
}
#/lua

#!lua
return setmetatable({}, { __index = lazy_load_gen(core_modules),
                                __call  = call_gen(core_modules) })
#/lua

