 * Cluster


One of the language-development goals we have with the Bridge project is to
build and extend a Meta-Object Protocol.

That's cluster.

**** imports

#!lua
local act = require "core:core/cluster/actor"
#/lua


** cluster

#!lua
local cluster = {}

for k, v in pairs(act) do
   cluster[k] = v
end
#/lua


** Identity and Membership


*** Inheritance


**** Meta

This is our default pattern for single inheritance with transference of
metamethods.

#!lua
local sub = assert(string.sub)

local isempty = table.isempty
                or
                function(tab)
                   local empty = true
                   for _, __ in next, tab, nil do
                      empty = false
                      break
                   end
                   return empty
                end

function cluster.Meta(Meta)
   if Meta and Meta.__index then
      -- inherit
      local tab = {}
      for field, value in next, Meta, nil do
         if sub(field, 1, 2) == "__" then
            tab[field] = value
         end
      end
      if Meta.__meta then
         tab.__meta = tab.__meta or {}
         for _, __ in next, Meta.__meta, nil do
            tab.__meta[_] = __
         end
      end
      tab.__index = tab
      return setmetatable(tab, Meta)

   elseif Meta
      and type(Meta) == 'table'
      and isempty(Meta) then
      -- decorate
      Meta.__index = Meta
      return Meta
   elseif not Meta then
      local _M = {}
      _M.__index = _M
      return _M
   end
   error ("cannot make metatable from type" .. type(Meta))
end
#/lua


**** __meta

The meta metatable.

Index looks up symbol resolution, such that on a self-indexed table, the
metafields and metamethods are available.  While this is untrue of a table
in which =__index= does not point to itself.

The cluster word =meta= will therefore post-copy out of a table called
=__meta=, if such a metametatable should happen to exist as the rvalue of
the =__meta= field.

Valid keys are only strings starting with a double underscore.  Valid values
would tend to be best thought of as tables and functions, with booleans
playing their usual role.  To put a point upon it, rules are not imposed here.



*** constructor(mt, new, instance?)

Wraps up a module metatable in a callable-table-style constructor, assigning
=idEst= appropriately on the metatable. =new= is assigned to =mt.__call=, or
if =nil=, we check to make sure one has already been provided.

If =instance= is provided, it is used for the instance, which is otherwise
created from a fresh table.

#!lua
function cluster.constructor(mt, new, instance)
   instance = instance or {}
   if new then
      mt.__call = new
   elseif not mt.__call then
      error "nil metatable passed to constructor without __call metamethod"
   end

   local constructor = setmetatable(instance, mt)
   mt.idEst = constructor
   return constructor
end
#/lua


*** methodchain(method)


  Allows for easy application of the pattern
=obj :message "param" "param" -> obj=.

This first implementation uses a 'launch table' on a per-method basis, and
is not suitable for reentrant use. I have a plan in mind for this, but want
the easier to write version first, because well, easier to write, and also
might be appreciably faster and worth keeping around for the occasional hot
loop.


#!lua
local insert, remove = assert(table.insert), assert(table.remove)


function cluster.methodchain(method)

   local value_catch = {}
   local remove = assert(table.remove)

   local function value__call(value_catch, value, ...)
      method(value_catch[1], value_catch[2], value, ...)
      value_catch[2] = nil
      return remove(value_catch)
   end

   setmetatable(value_catch, { __call = value__call })

   return function (obj, first)
      insert(value_catch, obj)
      insert(value_catch, first)
      return value_catch
   end
end
#/lua


*** indexafter(idx_fn, idx_super)

A decorator which returns a closure, suitable for =__index=, which first
looks up against the function and then against =idx_super=, which can be a
function or a table.

For a hotter code path, we detect the type of =idx_super= and return one of
two closures depending on the nature of the lookup.

#!lua
function cluster.indexafter(idx_fn, idx_super)
   if type(idx_super) == 'table' then
      return function(tab, key)
         local val = idx_fn(tab, key)
         if val then
            return val
         else
            return idx_super[key]
         end
      end
   elseif type(idx_super) == 'function' then
      return function(tab, key)
         local val = idx_fn(tab, key)
         if val then
            return val
         else
            return idx_super(tab,key)
         end
      end
   end
end
#/lua


*** instancememo(instance, message)

Takes an instance, and a message, and memoizes that particular message, for
the instance, against the first parameter.  That is, it will save the return
values of any call against that method, and key them against the /instance/,
not the method, returning any prior captured values.

#Future We might add a =constraints= parameter as an optional n-table, such
that when provided, the memo will also check that any keys indicated with
==key = true== also have the values they had before.  This also constrains
those objects to be tables, but is not intended as a type system so much as
a tripwire indicating that the prior memoized value isn't valid.

#!lua
local _instances = setmetatable({}, { __mode = 'k'})

function cluster.instancememo(instance, message)
   local memos = { [message] = {} }
   -- grab the method, we're going to need it later
   local method = instance[message]
   _instances[instance] = memos
   local function memo_method(inst, p, ...)
      local param_set = assert(_instances[inst][message],
                             "missing instance or message")
      local results = param_set[p]
      if results then return unpack(results) end

      results = pack(method(inst, p, ...))
      param_set[p] = results
      return unpack(results)
   end
   instance[message] = memo_method
end
#/lua


*** addsuper(Meta)

  An implementation of super-methods which respects the Lua Meta-Object
Protocol.  This is a metatable decorator which errors out if the index
heirarchy can't be successfully climbed.

On success, it adds a magic method =: super()= which returns a reusable
container table, which must be called with a message in string form, which is
looked up against the supertable and bound to the instance object when
called.

An illustration is in order:

#!lua #noKnit #example
local Gizmo = meta(Thing)
local Widget = meta(Widget)
super(Widget)

-- ...

new_widget("crankolater") :super 'stock' ()
#/lua

will generate a Widget instance, then call the supertable of

#Todo need my Lua parser fast but, continue this.

#!lua
--| if =fn= exists, bind fn(obj, ...)
local function _maybe_bind(obj, fn)
  if not fn then return nil end
  return function(...)
     return fn(obj, ...)
  end
end

local function _get_idx(obj)
   local M = getmetatable(obj)
   return M and M.__index
end

function cluster.super(obj, field)
   local super_idx
   -- If the object has such a field directly, consider the implementation
   -- from the metatable to be the "super" implementation
   if rawget(obj, field) then
      super_idx = _get_idx(obj)
   -- Otherwise, look one step further up the inheritance chain
   else
      local M_idx = _get_idx(obj)
      super_idx = type(M_idx) == 'table' and _get_idx(M_idx) or nil
   end
   if super_idx then
      return type(super_idx) == 'table'
         and _maybe_bind(obj, super_idx[field])
         or  _maybe_bind(obj, super_idx(obj, field))
   end
   -- No superclass, or our class uses an __index function so we can't
   -- meaningfully figure out what to do
   return nil
end
#/lua


#!lua
return cluster
#/lua
