* Function Extensions


  Various methods to extend the functionality of functions and methods,
methodically.

This is also the home of some core functions which are distinguished by their
actions, side effects, or effect on control flow, rather than by acting on
a specific data structure.  Currently this is limited to =assertfmt=.


**** imports

#!lua
local _base = require "core:core/_base"
#/lua


** fn table

#!lua
local fn = {}
#/lua


*** thunk(fn, ...)

Returns a function which, called, will call the function with the given
arguments.

#!lua
fn.thunk = assert(_base.thunk)
#/lua


*** partial(fn, ...)

Partial applicator: takes a function, and fills in the given arguments,
returning another function which accepts additional arguments:

#!lua-example
add5 = fn.partial(function(a,b)
                  return a + b
               end, 5)
return add5(10) -- returns 15
#/lua-example

#!lua
function fn.partial(fn, ...)
   local args = pack(...)
   return function(...)
      return fn(unpack(args, 1, args.n), ...)
   end
end
#/lua


*** itermap(fn, iter)

Applies =fn= to each element returned from =iter=, in turn.

For a consistent interface, all return values are =pack=ed into one array
slot of a table, which is returned.

#!lua
function fn.itermap(fn, iter)
   local ret, res = {}
   while true do
      res = pack(fn(iter()))
      if #res == 0 then
         return ret
      else
         ret[#ret + 1] = res
      end
   end
end
#/lua


*** dynamic(fn)

Because functions are immutable, we can't replace all instances of a function,
at least not without trawling the entire program with the =debug= library
looking for upvalues and locals.

=dynamic= returns a callable table, which calls the function with the given
arguments.  It also has a =patch= method, which replaces the calling function
with a new function.

Since tables are mutable, all instances of that function are thereby replaced.

#!lua
local function _patch(dynamic, fn)
   getmetatable(dynamic).__call = function(_, ...)
      return fn(...)
   end
end

local function dyn_newindex()
   error "Can't assign to a dynamic function"
end

function fn.dynamic(fn)
   return setmetatable({}, { __call = function(_, ...)
                                         return fn(...)
                                      end,
                             __index = { patch = _patch },
                             __newindex = dyn_newindex })
end
#/lua


** Errors and asserts


*** Assertfmt

I'll probably just globally replace assert with this over time.

This avoids doing concatenations and conversions on messages that we never
see in normal use.

#!lua
fn.assertfmt = _base.assertfmt
#/lua

#!lua
return fn
#/lua
