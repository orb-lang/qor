* Function Extensions


  Various methods to extend the functionality of functions and methods,
methodically.

This is also the home of some core functions which are distinguished by their
actions, side effects, or effect on control flow, rather than by acting on
a specific data structure.  Currently this is limited to =assertfmt=.


**** imports

#!lua
local _base = require "core:core/_base"
#/lua


** fn table

#!lua
local fn = {}
#/lua


*** curry(fn, param)

  Returns a function which pre-applies the given parameter to the first
position of the function.

We could simply do this naively, and LuaJIT being what it is, there's a decent
chance it would be optimized away.

But I prefer to provide a guarantee that, for up to five parameters, there is
exactly one level of indirection involved.

#!lua
local _curried = setmetatable({}, { __mode = 'k' })

local currier = {
   false, -- this shouldn't happen
   function(fn, a, b) -- [2]
      return function(...)
         return fn(a, b, ...)
      end
   end,
   function(fn, a, b, c) -- [3]
      return function(...)
         return fn(a, b, c, ...)
      end
   end,
   function(fn, a, b, c, d) -- [4]
      return function(...)
         return fn(a, b, c, d, ...)
      end
   end,
   function(fn, a, b, c, d, e) -- [5]
      return function(...)
         return fn(a, b, c, d, e, ...)
      end
   end,
}

function fn.curry(fn, param)
   assert(type(fn) == 'function', '#1 of curry must be a function')
   local curried;
   local pre = _curried[fn]
   if not pre then
      curried = function(...) return fn(param, ...) end
      _curried[curried] = { param, n = 1 , fn = fn }
   else
      if pre.n <= 4 then
         local post = {}
         for i = 1, pre.n do
            post[i] = pre[i]
         end
         post.n = pre.n + 1
         post.fn = pre.fn
         post[post.n] = param
         curried = currier[post.n](post.fn, unpack(post, 1, post.n))
         _curried[curried] = post
      else
         curried = function(...) return fn(param, ...) end
      end
   end

   return curried
end
#/lua



*** thunk(fn, ...)

Returns a function which, called, will call the function with the given
arguments.

#!lua
fn.thunk = assert(_base.thunk)
#/lua


*** partial(fn, ...)

Partial applicator: takes a function, and fills in the given arguments,
returning another function which accepts additional arguments:

#!lua-example
add5 = fn.partial(function(a,b)
                  return a + b
               end, 5)
return add5(10) -- returns 15
#/lua-example

#!lua
local function _unpacker(fn, args)
   return function(...)
      -- clone args
      local call = {}
      for i = 1, args.n do
         call[i] = args[i]
      end
      call.n = args.n
      -- add new args from ...
      for i = 1, select('#', ...) do
         call.n = call.n + 1
         call[call.n] = select(i, ...)
      end
      return fn(unpack(call, 1, call.n))
   end
end

function fn.partial(fn, ...)
   local args = pack(...)
   return _unpacker(fn, args)
end
#/lua


*** itermap(fn, iter)

Applies =fn= to each element returned from =iter=, in turn.

For a consistent interface, all return values are =pack=ed into one array
slot of a table, which is returned.

#!lua
function fn.itermap(fn, iter)
   local ret, res = {}
   while true do
      res = pack(fn(iter()))
      if #res == 0 then
         return ret
      else
         ret[#ret + 1] = res
      end
   end
end
#/lua


*** fn.dynamic(fn)

Because functions are immutable, we can't replace all instances of a function,
at least not without trawling the entire program with the =debug= library
looking for upvalues and locals.

=dynamic= sets up a closure, which uses a private attributes table to retrieve
the passed function and call it.

We create a table as a lightweight unique to index the function with, and
provide a second method, =fn.patch_dynamic=, to change the underlying function
when desired.

We use two tables for the registry, because we want the values of the
=_dynamics_call= table to retain a reference even if it's the only one, which
allows anonymous functions to be registered as dynamic or patched in.

The net result is a unique function which can be swapped out in all places in
which it is used.

#!lua
local _dynamics_call = setmetatable({}, {__mode = 'k'})
local _dynamics_registry  = setmetatable({}, {__mode = 'kv'})

function fn.dynamic(fn)
   -- make a unique table as key
   local uid = {}
   local function dyn_fn(...)
      return _dynamics_call[uid](...)
   end
   _dynamics_call[uid] = fn
   _dynamics_registry[dyn_fn] = uid
   return dyn_fn
end
#/lua


*** fn.patch_dynamic(dyn_fn, fn)

Replaces the attribute function with the new function, and updates the table
accordingly.

#!lua
function fn.patch_dynamic(dyn_fn, fn)
   assert(_dynamics_registry[dyn_fn], "cannot patch a non-dynamic function")
   local uid = _dynamics_registry[dyn_fn]
   _dynamics_call[uid] = fn
end
#/lua


*** hookable(fn)

As we build out =helm=, I would like to be able to expose a rich API for
extensions, a la Emacs.

One of the ways to do this is to expose functions with hooks: actions taken
before or after a given function.

Doing this well means not letting implementation get ahead of use; think of
this as a proof of concept.

A hookable function is a callable table with slots =pre= and =post=, which,
when present, are called before and after the function.

=pre= receives the same parameters, and must return parameters that are then
passed to the main function.  These don't have to be the same parameters,
but certainly can be, if pre is called for side effects.  This calling
convention gives =pre= a chance to modify the default parameters.

=post= receives the return values of the main function, if any, followed by
either the return parameters of =pre= or the main parameters, depending on if
there is a pre-hook.  The reason for this calling convention is that otherwise
the order of parameters changes if the =pre= hook is removed, making it
difficult to write a =post= hook which is unaware of what =pre= is doing.

This is because we don't want to have to structure the main function in a
parameter-passing style, but if it does return something, =post= should get a
shot at it.

The return values are the return values of =post= or the main function,
depending.

#!lua
local _hooks = setmetatable({}, {__mode = "k"})

local function hookable_newindex()
   error "Attempt to assign value to a hookable function"
end

local function call_with_hooks(hooked, fn, ...)
   local pre, post = _hooks[hooked].pre, _hooks[hooked].post

   if pre and post then
      local new_arg = pack(pre(...))
      return post(fn(unpack(new_arg)), unpack(new_arg))
   elseif pre then
      return fn(pre(...))
   elseif post then
      return post(fn(...), ...)
   else
      return fn(...)
   end
end

local function hookPre(hooked, pre_hook)
   _hooks[hooked].pre = pre_hook
end

local function hookPost(hooked, post_hook)
   _hooks[hooked].post = post_hook
end

local function unhookPre(hooked)
   _hooks[hooked].pre = nil
end

local function unhookPost(hooked)
   _hooks[hooked].post = nil
end

local hook_index = { hookPre    =  hookPre,
                     hookPost   =  hookPost,
                     unhookPre  =  unhookPre,
                     unhookPost =  unhookPost }

function fn.hookable(fn, pre, post)
   local hook_m = { __newindex = hookable_newindex,
                    __index    = hook_index,
                    __call = function(hooked, ...)
                                return call_with_hooks(hooked, fn, ...)
                             end }
   local hooked = setmetatable({}, hook_m)
   local hook_attr = { pre = pre, post = post }
   _hooks[hooked] = hook_attr
   return hooked
end

#/lua


** Errors and asserts


*** Assertfmt

I'll probably just globally replace assert with this over time.

This avoids doing concatenations and conversions on messages that we never
see in normal use.

#!lua
fn.assertfmt = _base.assertfmt
#/lua

#!lua
return fn
#/lua
