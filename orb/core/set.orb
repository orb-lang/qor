* Set

  A fundamental data structure for any language.

In Lua, the natural pattern for making a set is simply

#!lua #noKnit #example
stooge =  { "larry" = true, "moe" = true, "curly" = true }

if stooge["larry"] then
   print "nyuk nyuk nyuk"
end
#/lua

Which invites a certain amount of common behavior to eliminate verbosity.

Our first implementation stores Sets in this fashion, but also had methods,
with the obvious (in retrospect!) flaw that if the method name were to be a
member of the Set, then that method becomes shadowed.

The subsequent implementation uses indirection to prevent this, while
maintaining the methods, but we lost the ability to index a Set to test
membership.  Instead we would call it a la =stooge("larry")=, which works,
ok, but it isn't idiomatic Lua.

This time, no methods, only metamethods, and we use a callable constructor
library for the infrequent occasions when we need to do a Set operation we
can't represent through operators and metasyntax.

The collection of tables we build this with is a bit bespoke:

#!lua
local core = require "qor:core"
local Set, Set_Build, Set_M = {}, {}, {}
setmetatable(Set, Set_Build)
#/lua

Since we do /not/ want any __indexing on our instances, and we have different
semantics for __call on the library and on the instance.


*** Set(tab?) -> Set

  Half of the point of a dedicated Set is to allow the above set to be written
more compactly as =Set {"larry", "curly", "moe"}=.

Our constructor examines one argument, which must be =nil= or a table.  If a
table, /that table/ is used to construct the Set, which must be kept in mind
if, for example, one wants to use a common table to build up several Sets.

The technique for that is found in the next section.

#!lua
function Set_Build.__call(_new, tab)
   assert(type(tab) == 'table' or not tab, "#1 to Set must be a table or nil")
   tab = tab or {}
   local top = #tab
   local shunt;  -- we need this for number keys
   for i = 1, top do
      local v = tab[i]
      if type(v) == 'number' then
         shunt = shunt or {}
         shunt[v] = true
      else
         tab[v] = true
      end
      tab[i] = nil
   end
   if shunt then
      for v in pairs(shunt) do
         tab[v] = true
      end
   end
   return setmetatable(tab, Set_M)
end
#/lua


*** set(...) ->, aka Set.insert #disabled

  Calling a set adds all the elements to the Set.  As is normal with inserting
into tables, we do not return the set.

So to reuse an array table in several sets, =unpack= it into a call on the
Set you're setting up.

There are only two ways to add elements to sets, and this is one, with the
only other mutable operation being =set.remove(set, ...)=.

I'm turning this off until my type system can yell at me if I call it for its
return value...

#!lua
function Set_M.__call(set, ...)
   error
     "don't use Set(...) to mutate until we can warn about =if Set(elem)!="
   for i = 1, select('#', ...) do
      set[select(i, ...)] = true
   end
end

Set.insert = Set_M.__call
#/lua


*** set[index] = true

The other way to add elements is to set them to =true=.

We make sure the user doesn't /initially/ set values to anything but =true=,
but =__newindex= only applies to missing values, so elements can be set to
anything the user cares to, including =nil=, which is the only other intended
revalue.

We use truthiness rather than boolean truth, so this is reasonably forgiving
of storing unexpected values for Set elements.  We're striking the right
balance between simplicity, speed, and correctness here.

Be that as it may, I urge the user to restrict values in Set tables to =true=
or =nil=.

#!lua
function Set_M.__newindex(set, key, value)
   assert(value == true or value == nil, "value must be true or nil")
   rawset(set, key, value)
end
#/lua


*** Set.remove(set, ...) -> removed_elements : any

Removes any elements which are in the set, returning all the removed elements
in the parameter order, but with no =nil= values for elements which were not
removed.

TBH I'm not persuaded this is a good thing to offer, mutating sets by building
them up (for instance in a loop) is a reasonable pattern but this makes them
/actually mutable/ in a way we shouldn't need to support.

#!lua
insert = assert(table.insert)
function Set.remove(set, ...)
   local removed;
   for i = 1, select('#', ...) do
      local elem = select(i, ...)
      if set[elem] then
         removed = removed or {}
         insert(removed, elem)
         set[elem] = nil
      end
   end
   if removed then
      return(unpack(removed))
   end
end
#/lua


** Set metamethods and operations

  We put anything with a sensible signature into metamethods, because our
architecture forbids the ordinary kind.

It makes sense to intersperse these in with operations, which are provided by
the =Set= cassette, not the =Set_M= metatable.


*** __len

This one is refreshingly simple now that the only keys are the elements of the
set, it's literally just nkeys.

#!lua
Set_M.__len = assert(table.nkeys)
#/lua


*** Operators

  All operators create a new set, rather than mutating either of the inputs,
and will accept an array table as either the left or right value of a binary
operation.

There are two interesting cases for us (boring cases being when the
metamethods match), when the left or right is an ordinary array table, and
when the right (left is handled by fset) is an fset.


**** _binOp(left: Set?, right: Set?) -> set, set

A consistent surface to allow either side of the operation to be an array
table.

#!lua
local function _fix(tab)
   if getmetatable(tab) == Set_M then
      return tab, true
   else
      return Set(tab), false
   end
end

local function _binOp(left, right)
   local l_p, r_p;
   left, l_p = _fix(left)
   right, r_p = _fix(right)
   return left, right, l_p, r_p
end
#/lua


**** isFSet(maybe: table) -> boolean

  Much of the point of providing function sets is to allow them to compose,
both with themselves and with literal sets.


*** fset marker

There is a "right way" to do this compatible with =idest= but we'll circle
back to get that engineering right.

#!lua
local F__add = getmetatable(require "qor:core/fn-set"()) . __add
#/lua

#!lua
local function isFset(maybe)
   local _M = getmetatable(maybe)
   if _M and _M.__add == F__add then
      return true
   else
      return false
   end
end
#/lua


*** Union: __add   set + set

#!lua
local clone = assert(require "table.clone")

function Set_M.__add(left, right)
   -- Set union is commutative, but we need to clone to prevent subsequent
   -- mutation from changing the semantics
   if isFset(right) then
      return right + clone(left)
   end
   local l_isSet, r_isSet;
   left, right, l_isSet, r_isSet = _binOp(left, right)
   local set, other;
   if #left > #right then
      if l_isSet then
         set = clone(left)
      else
         set = left
      end
      other = right
   else
      if r_isSet then
         set = clone(right)
      else
         set = right
      end
      other = left
   end

   for elem in pairs(other) do
      set[elem] = true
   end
   return setmetatable(set, Set_M)
end
#/lua


*** Difference: __sub  set - set

Makes a new set missing any elements which are in the right set.

#!lua
function Set_M.__sub(left, right)
   left, right =  _binOp(left, right)
   local set = {}
   for k in pairs(left) do
      if not right[k] then
         set[k] = true
      end
   end
   return setmetatable(set, Set_M)
end
#/lua


*** Intersection: __mod  set % set

  I'm using =%= for intersection because mod is relatively infrequent, and the
mnemonic is that the =/= is the piscis of a Venn diagram showing a set
intersection.

As among the most useful set operations, and the last we can provide with
literal-minded sets, it would be a pity to relegate it to a library function.

#!lua
function Set_M.__mod(left, right)
   left, right = _binOp(left, right)
   local set = {}
   for elem in pairs(left) do
      if right[elem] then
         set[elem] = true
      end
   end
   return setmetatable(set, Set_M)
end
#/lua


*** __eq set == set

  Equality and subset comparisons require both sides to be of the same
metatable to have the same metamethod, so we can't coerce the sides.

Since we can cheaply test =nkeys=, these three are the same core operation:

#!lua
local function not_missing(left, right)
   for elem in pairs(left) do
      if not right[elem] then
         return false
      end
   end
   return true
end
#/lua

#!lua
function Set_M.__eq(left, right)
   if not #left == #right then return false end
   return not_missing(left, right)
end
#/lua


*** __lt set < set

Returns =true= if the left set is a proper subset of the right.

#!lua
function Set_M.__lt(left, right)
   if #left >= #right then return false end
   return not_missing(left, right)
end
#/lua


*** __repr

We show sets in the array style, to remove the redunandy of all the =true=
tokens.

#!lua
local wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)
local tabulate, Token
local sortedpairs = assert(core.table.sortedpairs)

function Set_M.__repr(set, window, c)
   tabulate = tabulate or require "repr:tabulate"
   Token = Token or require "repr:token"
   if #set == 0 then
      -- we have a name for this
      local sent = false
      return function()
         if not sent then
            sent = true
            local empty = "#{" .. c.table('âˆ…') .. "}"
            return empty
         end
      end
   end

   return wrap(function()
      yield(Token("#{ ", { color = "base", event = "array"}))
      local first = true
      window.depth = window.depth + 1
      for v, _ in sortedpairs(set) do
         if first then
            first = false
         else
            yield(Token(", ", { color = "base", event = "sep" }))
         end
         for t in tabulate(v, window, c) do
            yield(t)
         end
      end
      window.depth = window.depth - 1
      yield(Token(" }", { color = "base", event = "end" }))
   end)
end
#/lua


** Operators: NYI

  Writing the Set operations is beyond my interest in implementing at the moment.

The semantics are already defined in the other Set module, and it's a matter
of porting the algorithms and writing adequate sessions.

We are using set operations, at least in Voltron, so they're coming up soon.


#!lua
return Set
#/lua
