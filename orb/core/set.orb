* Set

  A fundamental data structure for any language.

In Lua, the natural pattern for making a set is simply

#!lua #noKnit #example
stooge =  { "larry" = true, "moe" = true, "curly" = true }

if stooge["larry"] then
   print "nyuk nyuk nyuk"
end
#/lua

Which invites a certain amount of common behavior to eliminate verbosity.

Our first implementation stores Sets in this fashion, but also had methods,
with the obvious (in retrospect!) flaw that if the method name were to be a
member of the Set, then that method becomes shadowed.

The subsequent implementation uses indirection to prevent this, while
maintaining the methods, but we lost the ability to index a Set to test
membership.  Instead we would call it a la =stooge("larry")=, which works,
ok, but it isn't idiomatic Lua.

This time, no methods, only metamethods, and we use a callable constructor
library for the infrequent occasions when we need to do a Set operation we
can't represent through operators and metasyntax.

The collection of tables we build this with is a bit bespoke:

#!lua
local Set, Set_Build, Set_M = {}, {}, {}
setmetatable(Set, Set_Build)
#/lua

Since we do /not/ want any __indexing on our instances, and we have different
semantics for __call on the library and on the instance.


*** Set(tab?) -> Set

  Half of the point of a dedicated Set is to allow the above set to be written
more compactly as =Set {"larry", "curly", "moe"}=.

Our constructor examines one argument, which must be =nil= or a table.  If a
table, /that table/ is used to construct the Set, which must be kept in mind
if, for example, one wants to use a common table to build up several Sets.

The technique for that is found in the next section.

#!lua
function Set_Build.__call(_new, tab)
   assert(type(tab) == 'table', "#1 to Set must be a table or nil")
   local top = #tab
   local shunt;  -- we need this for number keys
   for i = 1, top do
      local v = tab[i]
      if type(v) == 'number' then
         shunt = shunt or {}
         shunt[v] = true
      else
         tab[v] = true
      end
      tab[i] = nil
   end
   if shunt then
      for v in pairs(shunt) do
         tab[v] = true
      end
   end
   return setmetatable(tab, Set_M)
end
#/lua


*** set(...) ->, aka Set.insert

  Calling a set adds all the elements to the Set.  As is normal with inserting
into tables, we do not return the set.

So to reuse an array table in several sets, =unpack= it into a call on the
Set you're setting up.

There are only two mutations of sets offered, and this is one, the other one
is =set.remove(set, ...)= which removes elements as listed, and returns the
element iff they were there to be removed.

#!lua
function Set_M.__call(set, ...)
   for i = 1, select('#', ...) do
      set[select(i, ...)] = true
   end
end

Set.insert = Set_M.__call
#/lua


*** Set.remove(set, ...)

#!lua
function Set.remove(set, ...)

end
#/lua

#!lua
local wrap, yield = assert(coroutine.wrap), assert(coroutine.yield)
local tabulate, Token

function Set_M.__repr(set, window, c)
   tabulate = tabulate or require "repr:tabulate"
   Token = Token or require "repr:token"

   return wrap(function()
      yield(Token("#{ ", { color = "base", event = "array"}))
      local first = true
      window.depth = window.depth + 1
      for v, _ in pairs(set) do
         if first then
            first = false
         else
            yield(Token(", ", { color = "base", event = "sep" }))
         end
         for t in tabulate(v, window, c) do
            yield(t)
         end
      end
      window.depth = window.depth - 1
      yield(Token(" }", { color = "base", event = "end" }))
   end)
end
#/lua

#!lua
return Set
#/lua
