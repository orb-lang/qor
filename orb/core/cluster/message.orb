* Message


  We'll want a metatable and constructor here, and Messages should be
read-only after construction.



**** imports

#!lua
local core = require "core:core"

local meta = assert(core.Meta)

local readOnly = assert(core.readOnly)
#/lua


** Message

#!lua
local _Message = meta {}
#/lua


*** Message.mold(msg)

  Confirms validity of a Message, returning one of =(msg, check)= or
=(nil, check)=.

*Very* much an open question how this works.

#!lua
local _Message_fields = {
   'method'  = true,
   'message' = true,
   'sendto'  = true,
   'call'    = true,
}
#/lua


*** new(msg)

#!lua
local function new(msg)
   assert(type(msg) == 'table', "#1 must be a table")
   local Msg = {}
   for k, v in pairs(msg) do
      Msg[k] = v
   end
   return readOnly(setmeta(Msg, Message))
end
#/lua

*** Message API

The array portion of the Message will be parameters, if any, and =.n= is
always used.  We may as well make =#msg= return =.n= while we're at it.


**** fields

  This is inherently open-ended, in that we can make up a new kind of Message
whenever we need one.  A message can't /just/ be array parameters and =.n=,
that would imply some kind of default method we don't necessarily have.
=__call=?  That seems awkward, I'd rather that be expressed as
==call = true==.

For a request for action we need some of:

- method:  Says "receiver, call this method with the provided parameters".
           Value is a symbol.  Without =sendto=, the method is called on the
           receiver itself.

- sendto:  Because it can't be =for=.  This says "intended for whatever is
           living on the slot with this name".  Combines with =method=,
           =message=, and =call=.

           In general, an Actor can only act on messages using entities on its
           own slots, so that's explicitly the semantic of =sendto=.  We'll
           find ourselves needing more general dispatch eventually, with event
           Messages, but =sendto= will always mean "send this to your own slot
           with this name".

- message:  A Message which is dispatched to whatever is returned from
            dispatching *this* message. In other words, =={ call = "foo",
            message = { method = "bar", "baz" } }== ultimately evaluates to
            ==target.foo():bar("baz")==.  These may be nested arbitrarily deep
            to produce a chain of calls.

- call:  Value is either =true= or a symbol.  If a symbol, call the function
         at that slot with the parameters, if =true=, then call the receiver
         with the parameters.

- n:  Already mentioned, but for completeness, an integer >= 0 which specifies
      the number of parameters in the array portion of the Message.

> DS: Why have =sendto= when we already need a mechanism to decide who even
>     gets a message in the first place? (At its simplest this is just called
>     "knowing who's at the other end of a particular queue", and that may be
>     sufficient.) This is something of a rhetorical question--I can see
>     situations where we'd use it, but it's usually going to be a Law of
>     Demeter violation, and frankly I'd tend towards leaving it out until we
>     actually need it.

We'll need it immediately, when messages to modeS need to go to Historian.

DS: Right, I was putting a lot on "a mechanism to decide who even gets a
message in the first place" without realizing that this basically *is* that
mechanism. I do wonder how it interacts with Mailman, and especially my notion
of a MIMO Mailman with named "boxes". We certainly want to make sure that if
there's more than one way to send a message to someone, you identify them the
same way across the board.

>
>     It also seems like there's a lot of redundancy between =method=,
>     =sendto=, =message= and =call=. First off we could just use ==method =
>     "__call"== for that case. Strictly speaking this is ambiguous between a
>     function property in slot =__call= and a true metamethod, but (a) so
>     many of our metatables are self-indexed that there is usually no
>     difference, and (b) if there is a difference and you care, Something Is
>     Wrong, please don't. So I'd be fine with just special-casing that if the
>     method name is "__call" we just call the receiver. Or not, this is
>     orthogonal to the other simplification I'm suggesting.

A message is =target:message(...)=, a call is =target.call(...)= or if call is
=true=, it's =target(...)=.

As you point out, conflating calling with a method via =__call= gets mixed up
with whether the metatable is a self-table, so I'd rather have a mechanism
which works regardless of the minutiae of how we set up the instance.

DS: Right, non-method function calls. Yeah, in that case we need both so might
as well also disambiguate =target:__call(...)= from =target(...)=.

At that point though I would do:

- property: Just retrieve a property. No parameters allowed in this case.
            =={ property = "foo" }== -> =target.foo=.
- method: Call a method. =={ method = "foo", "bar" }== -> =target:foo("bar")=.
- call: Call a function (or the receiver itself if ==call = true==).
        =={ call = "foo", "bar" }== -> =target.foo("bar")=

No =sendto=, handle that with a nested message like
=={ property = "foo", message = { method = "bar", n = 1, "baz" } }==.

Alternatively, have =name= (a symbol) and =action= (one of {"property",
"call", "method"). This is convenient for implementation (we always need to
retrieve something, it's convenient to alsways store it under the same key)
but yes, it is a little string-ly typed.

>
>     That being, replace =sendto= and =message= with something like
>     =callpath= or =sendpath=, which is an array-table of keys to traverse in
>     order before calling the =method=. So =={ method = "baz", path = {
>     "foo", "bar" }}== would ultimately result in
>     =receiver.foo.bar.baz(...)=. But also, per my first paragraph, I would
>     tend to leave this out until we actually need it--indeed until we need
>     it *more than once*, the first time I would just write a forwarder
>     function on the receiver itself.

I considered and rejected that architecture.

Each target in a call path needs the same flexibility as the receiver of the
message.  The parsimonious way to handle that is to pass an entire Message in
the case where the primary receiver is forwarding the message to an Actor in
its call heirarchy.

We're going to want to bake message dispatch into the class definition of an
Actor, they're all going to be able to receive them.  So it will automatically
unwrap the envelope and dispatch the Message.

DS: Right, need nesting to be able to handle the full range of possibilities.
I updated the description of =message=, above.

As an additional affordance, we could allow...well, see above, I'm thinking we
don't actually need =sendto=, but we could allow it anyway *at construction
time*, and allow it to be a dotted path, and expand that into a nested message
like:

#!lua #noKnit
{ sendto = "foo.bar", method = "baz" }
-- becomes:
{ property = "foo", message = { property = "bar", message = { method = "baz" }}}
#/lua

-----

This gives us everything we need for an Actor to take action, but it then
needs to reply in many cases, so we need more for that.

Note that /every/ field in the above is optional, because a reply is also a
Message, and a reply doesn't have to come with a request for action, it can
just be an envelope around a payload.

So we'll need some more fields.  Here's a tentative list, I expect we'll be
working on this one for awhile to get it right.

- sender:  A name for the Actor sending the message.  This has some
           implications, in terms of wanting an Actor base class which knows
           its own name, and can craft Messages which provide that without
           explicitly adding it as a parameter.

> DS: +1 this is good.

- reply:  A flag.  When set to =true=, the Actor receiving the message is
          expected to package up the return value of the method call into a
          Message and send it back.

          Note that this is /a/ mechanism, not /the/ mechanism, for handling
          the result of a Message.  I'll discuss more options below when we
          start to flesh out the coroutine loop for Maestro activities.

          Just noting here that sometimes an Actor is in a position to hand
          off return values directly, and when that's the case, that's what we
          should do.

> DS: How would this be the case?

@atman: An example of this is the Maestro / Modeselektor coroutine loop.
        Actor dispatch will always =return= the value of the dispatch: if
        there's a =reply= flag, it packages those return values into a Message.

When there isn't, as in the coro loop, we have additional logic which handles
the return values: in this case, we call the dispatch inside =resume=, so
no need to =pack= and =unpack= the result.

DS: Right, I asked this and then later got clear about the
synchronous/asynchronous distinction. I'm still not really getting the
purpose/need for =reply= and =replyto=, honestly. Like, asynchronous messages,
in my experience, generally don't have "replies". They may prompt the person
receiving them to need to talk to someone, and that someone might happen to be
the sender of the original message, thus making it a sort of "reply", but it
still happens on the initiative of the receiver, rather than by request from
the original sender.

Also. This interacts with the whole thing of do we have a global Mailman with
named boxes, or route everything through modeS, or what? Like, it's not
automatically clear where to *start* when sending a reply--not the receiver,
but the receiver could itself be many levels deep, and we discussed how the
nesting thing is useful in that it *hides* that from the ultimate receiver, a
message looks the same no matter what path it took to get there.

- replyto:  I don't love this name, but =returnto= isn't great either, so it
            will do for a discussion.  The default reply is back to the sender,
            but the payload might not be intended directly for the sender, but
            rather someone living on one of his slots.

> DS: I would YAGNI this for now, and implement it as =replypath= analogous with
   =sendpath= if/when we need it.

@atman: Everything in this section is YAGNI. It's a draft.

- ret:  An ntable containing the return values of a reply Message.  This is
        what we call packaged return values in Valiant, and I see no reason to
        change that.  I'd say that we want the array portion of a Message to
        be only used for method-call parameters, because reusing it to return
        a payload in a reply would be confusing.

The intention here is that =sender= is used to route the reply Message, and
=replyto= becomes =sendto= in the reply (when present).  That gets us one
level deep, and only covers the case where the reply Message goes back to the
Actor who sent the first Message.

> DS: So a function call and return is fundamentally asymmetric. The caller
>     needs to know who they're talking to and get everything in order, the
>     callee just offers the return value up to the world without knowing who
>     it's going to. With an asynchronous messaging system, fundamentally
>     every message has to know its receiver, which means in order to reply,
>     you need to know the sender of a message. This is great so far.
>
>     But at that point, what makes a reply different from any other message?
>     Seems like...nothing, really? And when the reply gets back to its
>     sender, how does the sender know what to do with it? We could route all
>     "replies" through a single =_dispatchReply= function or something, but
>     that seems inferior to just...receiving new messages that happen to be
>     related to one that was sent earlier. In which case there's no need for
>     =ret=, it's just another message.
>
>     So. I would suggest, for now, that we start with =sender= (and the
>     implementation on Agent that you suggested to handle it automatically),
>     and any message that needs a reply, well, the receiver just sends an
>     appropriate message back. If we start seeing a lot of uses of this
>     pattern, and if for instance different senders of the same message want
>     different replies, then I would suggest making =reply= a sort of
>     "message prototype", a Message with everything filled in except the
>     sender, receiver, and arguments, which the reply-er will finish filling
>     in and send back. That takes care of all the nuances of where it goes
>     without adding any new fields.
>
>     All that said, also see below about how this interacts with the
>     coroutine loop, which suddenly *isn't* asynchronous.

@atman: good points.


We can and should extend the protocol when we have more complex routing, but
we should also avoid this!  Abstractions should pull their weight, and we
don't want the benefits we get from using an Actor-Message architecture to
evaporate in weird bespoke control flow, with actions bouncing around some
complex addressing scheme which has to be stepped through to really understand.

Unless we have no other choice, and at some point that might be the case.

It's always tempting to keep going on this kind of design work, but at the
moment it's unclear when we'll even use some of these fields.  It would make
sense for Maestro to include a request for a reply to a mouse click, but by
definition it doesn't know which Agent needs to handle it until Zoneherd
figures that out, and we don't really have to /tell/ Zoneherd to reply, it's
smart enough to just do that.

So let's take a look at the Maestro action loop.  At some point the Message
specific parts of this document will get broken out into a distinct Message
project, for now, these topics are related in a "what happens next" sort of
way, more than anything.
