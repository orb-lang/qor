* Thread


Bridge uses coroutines in combination with the =uv= event loop.

This is a home for primitives which make that a little cleaner.

#!lua
local uv = require "luv"
#/lua

#!lua
local thread = {}
#/lua


*** nest(tag)

  Assymetric coroutines are the best primitive a single-threaded language can
have for cooperative threading.  They get a bad rap sometimes, exactly because
they are primitive.  Any =yield= will find the next =resume= down on the call
stack, which is easy and composable when the user controls both the =resume=
and the =yield=.

Sometimes what we want is a system that behaves just like ordinary coroutines,
but with the =resume= and =yield= (and support functions) paired together, so
that this system ignores any =yield= which doesn't come from within it.

Wouldn't you know it, Phillipe Janda has solved this problem as well!  The
solution (and full copyright) may be found [[here]*].  Alban Linard, the
copyright holder, credits the former and I'm not surprised to hear it.

[*]:  https://github.com/saucisson/lua-coronest/blob/master/LICENSE

This will probably end up in a modified form, I'm checking it in with all the
copyright information and will of course leave the link to the license for as
long as it resolves.

As of the first commit, I've simply modified the main function to live on the
=thread= table, instead of being returned anoymously as one might expect from
a module.

I learned from this code a nice shorthand I wasn't aware of, ===val == ...===
means the same as ===val == select(1, ...)===.  Which does make sense given
that =...= is an anonymous tuple, but a single rvalue, so this is one of those
cases where it's 'demoted' to the first value, much like =f(a(), b())= will
use only the first return value of =a= but all of the return values of =b=.

#!lua #copyright 2014 Alban Linard #license MIT
local select       = select
local setmetatable = setmetatable
local create       = coroutine.create
local isyieldable  = coroutine.isyieldable -- luacheck: ignore
local resume       = coroutine.resume
local running      = coroutine.running
local status       = coroutine.status
local wrap         = coroutine.wrap
local yield        = coroutine.yield
#/lua

***** nest caches

  We use the first of these to make the return tables unique by tag, and the
second to convert strings to a private reference.

#!lua
local _tagged = setmetatable({}, {__mode = 'kv'})

local str_tags = setmetatable({}, {__mode = 'v'})
#/lua


**** nest(tag)

#!lua
function thread.nest(tag)
#/lua

First step is to convert a string tag into a unique table, which we use to
represent the coroutine pairings.

After this, we normalize missing tags into a unique table, and check our
cache to see if we've already built a nesting system for the first arguement.

If we have, we return it.

#!lua
  if type(tag) == 'string' then
     local _tag = str_tags[tag] or {}
     str_tags[tag] = _tag
     tag = _tag
  end

  tag = tag or {}

  if _tagged[tag] then
     return _tagged[tag]
  end
#/lua


***** The Easy Part

We make a new coroutine table as a drop-in replacement for stock =coroutine=.

Three functions require no modification:

#!lua
  local coroutine = {
    isyieldable = isyieldable,
    running     = running,
    status      = status,
  }

  _tagged[tag] = coroutine
#/lua

Having cached our return value, we need functions with the same interface as
those which remain.

A couple of those are easy.

#!lua
  function coroutine.create (f)
    return create (function (...)
      return tag, f (...)
    end)
  end


  function coroutine.yield (...)
    return yield (tag, ...)
  end
#/lua

The effect is to silently prepend the tag to the return value and yields,
respectively.


***** The Hard Part: Resuming

It's worth remembering that these threads will confuse =resume= in particular
if it sees one.  The goal is that they cooperate with each other, and stay out
of the way of a 'default' use of yield/resume.

This problem is solved with a rather splended and dense bit of code.

#!lua
  local function for_resume (co, ok, ...)
    if not ok then
      return ok, ...
    elseif tag == ... then
      return ok, select (2, ...)
    else
      return for_resume (co, resume (co, yield (...)))
    end
  end

  function coroutine.resume (co, ...)
    return for_resume (co, resume (co, ...))
  end
#/lua

We'll start from =coroutine.resume= and work down the inner call.

Our new =resume= has one line, and the innermost function merely calls the
real =resume= in the expected way.

Our helper =for_resume= picks up all those return values after the coroutine
itself, when the coroutine yields or returns.

The usual return signature from a coroutine is =ok, ...=, and ours will have
=ok, tag, ...=.  If =ok= is false, =for_resume= is a pass-through.

Otherwise we check for our tag, and if we see it, then we behave like resume
would and return the remaining arguments.

If we don't see our tag, we make a recursive tail call.  Inside out, this
yields /our/ coroutine with the values passed through, resuming it whenever it
it's resumed elsewhere.

Hence /nested/ coroutines.  The easy-to-understand version of this system two
pairs, the "inner" and "outer", where yields within the inner system stay
there, and outer yields are promoted to the outer handler, but resume back
into the inner system, which can continue to handle yields in the same way.

This /should/ work as expected if the outermost handler expects ordinary
coroutines.  I'm aiming to build =helm= and =actor= on that basis if I can.
The alternative appears to be only ever using nests.

Having deciphered =resume=, =wrap= is the functionalized version thereof:

#!lua
  local function for_wrap (co, ...)
    if tag == ... then
      return select (2, ...)
    else
      return for_wrap (co, co (yield (...)))
    end
  end

  function coroutine.wrap (f)
    local co = wrap (function (...)
      return tag, f (...)
    end)
    return function (...)
      return for_wrap (co, co (...))
    end
  end
#/lua

Which creates an extra closure relative to ordinary =wrap=, a modest price to
pay.

#!lua
  return coroutine
end
#/lua changes #copyright 2022 Sam Atman


*** onloop()

A predicate which returns =true= if we're inside a =uv= event loop and inside
a coroutine: which means we can register a callback, =yield=, and =resume=
inside the callback.

Used to write "purple" functions, which are colored red or blue depending on
whether or not we're handling things asynchronously.

#!lua
function thread.onloop()
   local _, main = running()
   return main and uv.loop_alive()
end
#/lua


*** canyield(...)

If we're inside a coroutine, =yield= the values, otherwise, return them.

This should let us write functions which are either blocking or non-blocking,
with some care, by wrapping async operations in 'purple' functions and using
=canyield= to mark points where, in the service of e.g. resynchronizing, we
might want to surrender control.

#!lua
function thread.canyield(...)
   local _, main = running()
   if not main then
      yield(...)
   else
      return ...
   end
end
#/lua

#!lua
return thread
#/lua
