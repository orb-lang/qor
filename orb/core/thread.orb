* Thread


Bridge uses coroutines in combination with the =uv= event loop.

This is a home for primitives which make that a little cleaner.

#!lua
local uv = require "luv"
#/lua

Thread debugging is print and pray.

#!lua
local s = require "status:status" ()
s.verbose = true
#/lua

#!lua
local thread = {}
#/lua


#!lua
local select       = select
local pack         = pack
local setmetatable = setmetatable
local create       = coroutine.create
local isyieldable  = coroutine.isyieldable
local resume       = coroutine.resume
local running      = coroutine.running
local status       = coroutine.status
local wrap         = coroutine.wrap
local yield        = coroutine.yield
#/lua


*** observe(thread, ...)

  This replaces the =ok= value of any successful call to a coroutine with its
status.  Instead of e.g. =true, "value"= we get ='suspended', "value"=.

There being occasions when suspended vs. dead is meaningful, this lets us
smoothly detect the difference between yielded and returned values.


#!lua
function thread.observe(co, ...)
   local rets = pack(resume(co, ...))
   local ok, stat = rets[1], status(co)
   if not ok then
      error(rets[2])
   else
      return stat, unpack(rets, 2)
   end
end
#/lua

For now, I'm leaving this here until I feel like I want it again, if it's
just a whim or I come up with a better name, we'll cross that stream when we
bridge it.

Clearly, to use this we need a nested version.

Speaking of which:


*** nest(tag)

#Original #Copyright 2014 Alban Linard #License MIT

  Assymetric coroutines are the best primitive a single-threaded language can
have for cooperative threading.  They get a bad rap sometimes, exactly because
they are primitive.  Any =yield= will find the next =resume= down on the call
stack, which is easy and composable when the user controls both the =resume=
and the =yield=.

Sometimes what we want is a system that behaves just like ordinary coroutines,
but with the =resume= and =yield= (and support functions) paired together, so
that this system ignores any =yield= which doesn't come from within it.

Wouldn't you know it, Phillipe Janda has solved this problem as well!  The
solution (and full copyright) may be found [[here]*].  Alban Linard, the
copyright holder, credits the former and I'm not surprised to hear it.

[*]:  https://github.com/saucisson/lua-coronest/blob/master/LICENSE

I learned from this code a nice shorthand I wasn't aware of, ===val == ...===
means the same as ===val == select(1, ...)===.  Which does make sense given
that =...= is an anonymous tuple, but a single rvalue, so this is one of those
cases where it's 'demoted' to the first value, much like =f(a(), b())= will
use only the first return value of =a= but all of the return values of =b=.


***** nest caches

  We use the first of these to make the return tables unique by tag, and the
second to convert strings to a private reference.

#!lua
local _tagged = setmetatable({}, {__mode = 'kv'})

local str_tags = setmetatable({}, {__mode = 'v'})
#/lua


**** nest(tag)

#!lua
local unique = require "qor:core".unique

function thread.nest(tag)
#/lua

First step is to convert a string tag into a unique table, which we use to
represent the coroutine pairings.

After this, we normalize missing tags into a unique table, and check our
cache to see if we've already built a nesting system for the first arguement.

If we have, we return it.

#!lua
if type(tag) == 'string' then
   local _tag = str_tags[tag] or unique()
   str_tags[tag] = _tag
   tag = _tag
end

tag = tag or unique()

if _tagged[tag] then
   return _tagged[tag]
end
#/lua


***** The Easy Part

We make a new coroutine table as a drop-in replacement for stock =coroutine=.

Three functions require no modification:

#!lua
local coroutine = {
   isyieldable = isyieldable,
   running     = running,
   status      = status,
}

_tagged[tag] = coroutine
#/lua

Having cached our return value, we need functions with the same interface as
those which remain.

A couple of those are easy.

#!lua
local _ours = setmetatable({}, {__mode = 'k'})

function coroutine.create(f)
   local co =  create(function(...)
      assert(type(tag) == 'userdata')
      return tag, f(...)
   end)
   _ours[co] = true
   return co
end

function coroutine.yield(...)
   return yield(tag, ...)
end
#/lua

The effect is to silently prepend the tag to the return value and yields,
respectively.  We keep track of coroutines created in this fashion so we can
provide a function to test for our coroutines.


***** The Hard Part: Resuming

It's worth remembering that these threads will confuse =resume= in particular
if it sees one.  The goal is that they cooperate with each other, and stay out
of the way of a 'default' use of yield/resume.

This problem is solved with a rather splendid and dense bit of code.

#!lua
local function for_resume(co, ok, ...)
   if not ok then
      return ok, ...
   elseif tag == ... then
      return ok, select(2, ...)
   else
       return for_resume(co,
                            resume(co,
                                      yield(...)))
   end
end

function coroutine.resume(co, ...)
   return for_resume(co,
                        resume(co, ...))
end
#/lua

The tail calls are indented to give a distinct stack frame to each place
something can go wrong!

We'll start from =coroutine.resume= and work down the inner call.

Our new =resume= has one line, and the innermost function merely calls the
builtin =resume= in the expected way.

Our helper =for_resume= picks up all those return values after the coroutine
itself, when the coroutine yields or returns.

The usual return signature from a coroutine is =ok, ...=, and ours will have
=ok, tag, ...=.  If =ok= is false, =for_resume= is a pass-through.

Otherwise we check for our tag, and if we see it, then we behave like resume
would and return the remaining arguments.

If we don't see our tag, we make a recursive tail call.  Inside out, this
yields /our/ coroutine with the values passed through, resuming it whenever it
it's resumed elsewhere.

Hence /nested/ coroutines.  The easy-to-understand version of this system two
pairs, the "inner" and "outer", where yields within the inner system stay
there, and outer yields are promoted to the outer handler, but resume back
into the inner system, which can continue to handle yields in the same way.

This works as expected if the outermost handler expects ordinary coroutines.

Having deciphered =resume=, =wrap= is the functionalized version thereof:

#!lua
local function for_wrap(co, ...)
   if tag == ... then
      return select(2, ...)
   else
      return for_wrap(co,
                         co(
                            yield(...)))
   end
end

function coroutine.wrap (f)
   local co = wrap (function (...)
      return tag, f (...)
   end)
   return function(...)
      return for_wrap(co,
                        co(...))
   end
end
#/lua


*** ours(co) -> boolean

Returns =true= if this nest created the coroutine.

I added this for debugging, but I anticipate it being a useful question to
answer, if, for example, we've been passed a coroutine and have two functions
with which to yield it.

As a reminder, the only thing this function tells us is if our nest created
the coroutine.  It isn't the coroutines which are special, with the exception
(an important one) of the final return value, but rather the nests.

#!lua
function coroutine.ours(co)
   return not not _ours[co]
end
#/lua

#!lua
return coroutine
#/lua

#!lua
end
#/lua changes #copyright 2022 Sam Atman


**** The Use of Nests

  Just a place to put a hunch that nested coroutines might be a good place to
put the condition/restart system.


** Thread Predicates


*** complete(ok, co)

Encapsulates the frequent check for a normal exit into one function.

#!lua
function thread.complete(ok, co)
   if ok and status(co) == 'dead' then
      return true
   else
      return false
   end
end
#/lua


*** onloop()

A predicate which returns =true= if we're inside a =uv= event loop and inside
a coroutine: which means we can register a callback, =yield=, and =resume=
inside the callback.

Used to write "purple" functions, which are colored red or blue depending on
whether or not we're handling things asynchronously.

#!lua
function thread.onloop()
   local _, main = running()
   return main and uv.loop_alive()
end
#/lua


*** canyield(...)

If we're inside a coroutine, =yield= the values, otherwise, return them.

This should let us write functions which are either blocking or non-blocking,
with some care, by wrapping async operations in 'purple' functions and using
=canyield= to mark points where, in the service of e.g. resynchronizing, we
might want to surrender control.

#!lua
function thread.canyield(...)
   local _, main = running()
   if not main then
      yield(...)
   else
      return ...
   end
end
#/lua

#!lua
return thread
#/lua
