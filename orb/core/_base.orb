* Core base


This contains parts of the core module system which are used within the core
module system.

Nothing in this module should be invoked directly, except by core; everything
in it is attached to one of the other submodules.

#!lua
local _base = {}
#/lua


*** no_op()

Sometimes you just need =(fn $)= y'know?

Why not have just one?

#!lua
function _base.no_op()
   return
end
#/lua


*** thunk(fn, ...)

Returns a function which, called, will call the function with the given
arguments.

#!lua
function _base.thunk(fn, ...)
   local args = pack(...)
   return function()
      return fn(unpack(args, 1, args.n))
   end
end
#/lua


*** assertfmt(pred, msg, ...)

#!lua
local format = assert(string.format)

function _base.assertfmt(pred, msg, ...)
   if pred then
      return pred
   else
      error(format(msg, ...), 2)
   end
end
#/lua


*** iscallable

Defined in both =table= and =fn=, since the arguments returning true are one
or the other of these.

#!lua
function _base.iscallable(val)
   if type(val) == 'function' then return true end
   if type(val) == 'table' then
      local M = getmetatable(val)
      if M and rawget(M, "__call") then
         return true
      end
   end
   return false
end
#/lua


*** unique()

Uses =newproxy= if available, providing a fresh table otherwise.

Call =unique= when you want a value whose only property is uniqueness.

#!lua
local newproxy = newproxy or function() return {} end
#/lua

#!lua
function _base.unique()
   return newproxy()
end
#/lua


*** lazyloader(lazy_table) -> lazyloader

  This produces a callable table, from a map from table names to =require=
compatible module strings.

Subsequently, =lazyloader.field= will call =require= on the appropriate string,
returning the value after caching it.

The lazy loader may be called at any point =(lazyloader(env?))=, which will
eagerly load every module from the lazy table.  If =env= is provided, these
key / value pairs are also written to that table, which will make them global
in the intended case where =env= is in fact a fenv somewhere.

We do this by making two closures over the table, one for the index:

#!lua
local function lazy_load_gen(requires)
   return function(tab, key)
      if requires[key] then
         -- put the return on the core table
         tab[key] = require(requires[key])
         return tab[key]
      else
         error("core doesn't have a module " .. tostring(key))
      end
   end
end
#/lua

And one for calling:

#!lua
local function call_gen(requires)
   return function(tab, env)
      local _;
      for k in pairs(requires) do
         _ = tab[k]
         if env then
            -- assign the now cached value as a global or at least slot
            env[k] = tab[k]
         end
      end
      return tab
   end
end
#/lua

The function merely builds a callable from the provided table.

#!lua
function _base.lazyloader(lazy_table)
   return setmetatable({}, { __index = lazy_load_gen(lazy_table),
                             __call  = call_gen(lazy_table) })
end
#/lua

#!lua
return _base
#/lua
